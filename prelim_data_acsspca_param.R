args <- commandArgs()
# define arguments
setwd <- args[6]
xfile <- args[7]
yfile <- args[8]
afile <- args[9]
lambda <- args[10]
npc <- as.numeric(args[11])
nfolds <- as.numeric(args[12])
sparams <- args[13]
ykernel <- args[14]
akernel <- args[15]
c1 <- as.numeric(args[16])
maxiter <- as.numeric(args[17])
delta <- as.numeric(args[18])
filter <- as.numeric(args[19])
minmaxsep <- as.numeric(args[20])
cat("setwd: ",setwd,"\n")
cat("xfile: ", xfile,"\n")
cat("yfile: ",yfile,"\n")
cat("afile: ",afile,"\n")
cat("lambda: ",lambda,"\n")
cat("npc: ",npc,"\n")
cat("nfolds: ",nfolds,"\n")
cat("sparams: ",sparams,"\n")
cat("ykernel: ",ykernel,"\n")
cat("akernel: ",akernel,"\n")
cat("c1: ",c1,"\n")
cat("maxiter: ",maxiter,"\n")
cat("delta: ",delta,"\n")
cat("filter: ",filter,"\n")
cat("minmaxsep: ",minmaxsep,"\n")
## check parameters
cat("read in arguments \n")
cat("about to read in data \n")
X <- read.table(xfile, header=T)
cat("successfully loaded X data \n")
Y <- read.table(yfile, header=T)
cat("successfully loaded Y data \n")
A <- read.table(afile, header=T)
cat("successfully loaded A data \n")
colnames(X) <- paste0("x",1:dim(X)[[2]])
colnames(Y) <- "y"
colnames(A) <- paste0("a",1:dim(A)[[2]])
xnames <- colnames(X)
ynames <- colnames(Y)
anames <- colnames(A)
cat("defined new column names for data frames \n")
X <- as.matrix(X)
cat("converted X to matrix \n")
Y <- as.matrix(Y)
cat("converted Y to matrix \n")
A <- as.matrix(A)
cat("converted A to matrix \n")
spm <- read.table(file=sparams, header=F) |> as.matrix() |> as.vector()
lambdas <- read.table(file=lambda, header=F) |> as.matrix() |> as.vector()
cat("read in sparse data \n")
cat("read in and converted all data \n")
n <- nrow(X)
p <- ncol(X)
cat("determining n and p \n")
cat("data successfully loaded \n")

if(nrow(Y)!=n) stop("number of observations in predictors and response must match")

if(min(spm) < 1) stop("minimum number of nonzero loadings must be greater than or equal to one")
if(max(spm) > sqrt(p)) stop("maximum number of nonzero loadings must be less than or equal to the square root of the number of predictors")
sp.arg <- spm

if(min(lambdas) < 0) stop("provide non-negative lambdas")

cat("successfully passed QC, sparse, and lambda parameters step \n")

if(ykernel!="linear" && ykernel!="delta") stop("Please select a valid Y kernel")
if(akernel!="linear" && ykernel!="gaussian") stop("Please select a valid A kernel")
df <- data.frame(Y,A,X)
cat("combined Y,A, and X into dataframe \n")
n.sp <- length(sp.arg)
cat("count number of sparse arguments to cross-validate \n")
cat("set up arguments \n")

df.partition <- groupdata2::fold(data=df,k=nfolds)

cat("partitioned data successfully \n")
fold.arg <- c(1:nfolds)
param.grid <- expand.grid(fold.arg,sp.arg,lambdas)
colnames(param.grid) <- c("fold.arg","sp.arg","lambdas")
cat("set up argument grid \n")
fpath <- paste(setwd,"temp",sep="")
dfpath <- paste(fpath,"/df.txt",sep="")
parampath <- paste(fpath,"/param.txt",sep="")
spath <- paste(fpath,"/sparg.txt",sep="")
lpath <- paste(fpath,"/lambdas.txt",sep="")
xnpath <- paste(fpath,"/xnames.txt",sep="")
ynpath <- paste(fpath,"/ynames.txt",sep="")
anpath <- paste(fpath,"/anames.txt",sep="")
cat("set up paths \n")
write.table(df.partition,file=dfpath,row.names = F,col.names = T,quote=F)
cat("save partitioned data \n")
write.table(param.grid,file=parampath,row.names = F,col.names = T,quote=F)
cat("save parameter grid \n")
write.table(sp.arg,file=spath,quote=F)
cat("save sparse argument vector \n")
write.table(lambdas,file=lpath,quote=F)
cat("save lambdas argument vector \n")
write.table(xnames,file=xnpath,quote=F)
cat("save x names vector \n")
write.table(ynames,file=ynpath,quote=F)
cat("save y names vector \n")
write.table(anames,file=anpath,quote=F)
cat("save a names vector \n")

